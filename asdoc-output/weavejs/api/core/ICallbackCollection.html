<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../../override.css" type="text/css"><meta name="keywords" content="ICallbackCollection,weavejs.api.core.ICallbackCollection,BYPASS_DIFF,CLASS_NAME,OBJECT_NAME,SESSION_STATE,callbacksAreDelayed,childListCallbacks,data,deprecatedStateMapping,foundPlaceholder,frameCallbacks,internalObject,lastNameAdded,lastNameRemoved,lastObjectAdded,lastObjectRemoved,locked,reverseLayout,target,targetPath,triggerCounter,typeRestriction,addDisposeCallback,addGroupedCallback,addImmediateCallback,addTask,alterSessionStateToBypassDiff,assignBusyTask,callLater,combineDiff,computeDiff,copySessionState,create,delayCallbacks,deprecatedPathRewrite,dispose,disposeObject,generateUniqueName,getCallbackCollection,getClassInfo,getClassName,getDefinition,getDisplayName,getImplementations,getLinkableDescendants,getLinkableObjectFromCallbackCollection,getLinkableOwner,getName,getNames,getNormalizedProgress,getObject,getObject,getObjects,getOwner,getPath,getSessionState,getSessionState,getSessionState,getSingletonInstance,getTaskCount,getText,hasTask,isBusy,isDynamicState,isDynamicStateArray,linkSessionState,linkableObjectIsBusy,lock,newDisposableChild,newLinkableChild,objectIsLocked,objectWasDisposed,registerClass,registerDisposableChild,registerImplementation,registerLinkableChild,removeAllObjects,removeCallback,removeObject,removeObject,removeTask,removeTypeFromState,renameObject,requestGlobalObject,requestLocalObject,requestLocalObjectCopy,requestObject,requestObjectCopy,resumeCallbacks,setNameOrder,setObject,setSessionState,setSessionState,setSessionState,startTask,toMap,toObject,traverseState,triggerCallbacks,unassignBusyTask,unlinkSessionState,updateTask"><title>weavejs.api.core.ICallbackCollection</title></head><body><script language="javascript" type="text/javascript" src="../../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../../help.js"></script><script language="javascript" type="text/javascript" src="../../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'ICallbackCollection - API Documentation';
				var baseRef = '../../../';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">API Documentation</td><td class="titleTableTopNav" align="right"><a href="../../../package-summary.html" onclick="loadClassListFrame('../../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../../class-summary.html" onclick="loadClassListFrame('../../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../../all-index-A.html" onclick="loadClassListFrame('../../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../../index.html?weavejs/api/core/ICallbackCollection.html&amp;weavejs/api/core/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">ICallbackCollection</td><td class="titleTableSubNav" id="subNav" align="right"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("ICallbackCollection"); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,false,false	,false,false,false,false,false);}	
				-->
			</script><div xmlns:fn="http://www.w3.org/2005/xpath-functions" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Package</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">weavejs.api.core</a></td></tr><tr><td class="classHeaderTableLabel">Interface</td><td class="classSignature">public  interface  ICallbackCollection extends  <a href="../../../weavejs/api/core/ILinkableObject.html">ILinkableObject</a></td></tr><tr><td class="classHeaderTableLabel">Implementors</td><td> <a href="../../../weavejs/core/CallbackCollection.html">CallbackCollection</a>,  <a href="../../../weavejs/core/LinkableDynamicObject.html">LinkableDynamicObject</a>,  <a href="../../../weavejs/core/LinkableVariable.html">LinkableVariable</a></td></tr></table><p></p><p></p><p></p>
	 This is an interface for adding and removing callback functions, and triggering them.
	 
	 <p></p><br/><hr></div><a name="propertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#callbacksAreDelayed" class="signatureLink">callbacksAreDelayed</a> : Boolean<div class="summaryTableDescription">[read-only] 
		 While this is true, it means the delay count is greater than zero and the effects of
		 triggerCallbacks() are delayed until resumeCallbacks() is called to reduce the delay count.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#triggerCounter" class="signatureLink">triggerCounter</a> : uint<div class="summaryTableDescription">[read-only] 
		 This counter gets incremented at the time that callbacks are triggered, before they are actually called.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr></table></div><a name="methodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#addDisposeCallback()" class="signatureLink">addDisposeCallback</a>(relevantContext:Object, callback:Function, allowDelay:Boolean = false):void</div><div class="summaryTableDescription">
		 This will add a callback that will only be called once, when this callback collection is disposed.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#addGroupedCallback()" class="signatureLink">addGroupedCallback</a>(relevantContext:Object, groupedCallback:Function, triggerCallbackNow:Boolean = false, delayWhileBusy:Boolean = true):void</div><div class="summaryTableDescription">
		 Adds a callback that will only be called during a scheduled time each frame.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#addImmediateCallback()" class="signatureLink">addImmediateCallback</a>(relevantContext:Object, callback:Function, runCallbackNow:Boolean = false, alwaysCallLast:Boolean = false):void</div><div class="summaryTableDescription">
		 This adds the given function as a callback.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#delayCallbacks()" class="signatureLink">delayCallbacks</a>():void</div><div class="summaryTableDescription">
		 This will delay the effects of triggerCallbacks() until a matching call is made to resumeCallbacks().</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#removeCallback()" class="signatureLink">removeCallback</a>(relevantContext:Object, callback:Function):void</div><div class="summaryTableDescription">
		 This function will remove a callback that was previously added.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#resumeCallbacks()" class="signatureLink">resumeCallbacks</a>():void</div><div class="summaryTableDescription">
		 This should be called after delayCallbacks() to resume the callbacks.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#triggerCallbacks()" class="signatureLink">triggerCallbacks</a>():void</div><div class="summaryTableDescription">
		 This will increase the triggerCounter, run immediate callbacks, and trigger grouped callbacks to be called later.</div></td><td class="summaryTableOwnerCol">ICallbackCollection</td></tr></table></div><script language="javascript" type="text/javascript"><!--
										showHideInherited();
										--></script><div class="MainContent"><div class="detailSectionHeader">Property Detail</div><a name="propertyDetail"></a><a name="callbacksAreDelayed"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">callbacksAreDelayed</td><td class="detailHeaderType">property</td></tr></table><div class="detailBody"><code>callbacksAreDelayed:Boolean</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 While this is true, it means the delay count is greater than zero and the effects of
		 triggerCallbacks() are delayed until resumeCallbacks() is called to reduce the delay count.
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get callbacksAreDelayed():Boolean</code><br/><p><span class="label">See also</span></p><div class="seeAlso"><a href="ICallbackCollection.html#delayCallbacks()" target="">delayCallbacks()</a><br/><a href="ICallbackCollection.html#resumeCallbacks()" target="">resumeCallbacks()</a></div></div><a name="propertyDetail"></a><a name="triggerCounter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">triggerCounter</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>triggerCounter:uint</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 This counter gets incremented at the time that callbacks are triggered, before they are actually called.
		 It is necessary in some situations to check this counter to determine if cached data should be used.
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get triggerCounter():uint</code><br/><p><span class="label">See also</span></p><div class="seeAlso"><a href="ICallbackCollection.html#triggerCallbacks()" target="">triggerCallbacks()</a></div></div><a name="methodDetail"></a><div class="detailSectionHeader">Method Detail</div><a name="addDisposeCallback()"></a><a name="addDisposeCallback(Object,Function,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">addDisposeCallback</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td></tr></table><div class="detailBody"><code> public function addDisposeCallback(relevantContext:Object, callback:Function, allowDelay:Boolean = false):void</code><p></p><p></p><p>
		 This will add a callback that will only be called once, when this callback collection is disposed.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">relevantContext</span>:Object</code> &mdash; If this is not null, then the callback will be removed when the relevantContext object is disposed via SessionManager.dispose().  This parameter is typically a 'this' pointer.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">callback</span>:Function</code> &mdash; The function to call when this callback collection is disposed.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">allowDelay</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If this is set to true, this callback will be delayed while callbacksAreDelayed is true.
		 </td></tr></table></p></div><a name="addGroupedCallback()"></a><a name="addGroupedCallback(Object,Function,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">addGroupedCallback</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function addGroupedCallback(relevantContext:Object, groupedCallback:Function, triggerCallbackNow:Boolean = false, delayWhileBusy:Boolean = true):void</code><p></p><p></p><p>
		 Adds a callback that will only be called during a scheduled time each frame.  Grouped callbacks use a central trigger list,
		 meaning that if multiple ICallbackCollections trigger the same grouped callback before the scheduled time, it will behave as
		 if it were only triggered once.  For this reason, grouped callback functions cannot have any parameters.  Adding a grouped
		 callback to a ICallbackCollection will undo any previous effects of addImmediateCallback() or addDisposeCallback() made to the
		 same ICallbackCollection.  The callback function will not be called recursively as a result of it triggering callbacks recursively.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">relevantContext</span>:Object</code> &mdash; The 'this' argument for the callback. The callback will be removed when the relevantContext object is disposed via Weave.dispose().
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">groupedCallback</span>:Function</code> &mdash; The callback function that will only be allowed to run during a scheduled time each frame.  It must not require any parameters.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">triggerCallbackNow</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If this is set to true, the callback will be triggered to run during the scheduled time after it is added.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">delayWhileBusy</span>:Boolean</code> (default = <code>true</code>)<code></code> &mdash; Specifies whether to delay the callback while the object is busy.
		                       Once a given relevantContext/groupedCallback pair has been added with delayWhileBusy enabled,
		                       it will remain enabled even if the delayWhileBusy parameter is set to false in subsequent calls
		                       to addGroupedCallback() with the same relevantContext/groupedCallback parameters.
		 </td></tr></table></p></div><a name="addImmediateCallback()"></a><a name="addImmediateCallback(Object,Function,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">addImmediateCallback</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function addImmediateCallback(relevantContext:Object, callback:Function, runCallbackNow:Boolean = false, alwaysCallLast:Boolean = false):void</code><p></p><p></p><p>
		 This adds the given function as a callback.  The function must not require any parameters.
		 The callback function will not be called recursively as a result of it triggering callbacks recursively.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">relevantContext</span>:Object</code> &mdash; The 'this' argument for the callback. The callback will be removed when the relevantContext object is disposed via Weave.dispose().
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">callback</span>:Function</code> &mdash; The function to call when callbacks are triggered.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">runCallbackNow</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If this is set to true, the callback will be run immediately after it is added.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alwaysCallLast</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If this is set to true, the callback will be always be called after any callbacks that were added with alwaysCallLast=false.  Use this to establish the desired child-to-parent triggering order.
		 </td></tr></table></p></div><a name="delayCallbacks()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">delayCallbacks</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function delayCallbacks():void</code><p></p><p></p><p>
		 This will delay the effects of triggerCallbacks() until a matching call is made to resumeCallbacks().
		 Pairs of calls to delayCallbacks() and resumeCallbacks() can be nested.
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="ICallbackCollection.html#resumeCallbacks()" target="">resumeCallbacks()</a><br/><a href="ICallbackCollection.html#callbacksAreDelayed" target="">callbacksAreDelayed</a></div></div><a name="removeCallback()"></a><a name="removeCallback(Object,Function)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">removeCallback</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function removeCallback(relevantContext:Object, callback:Function):void</code><p></p><p></p><p>
		 This function will remove a callback that was previously added.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">relevantContext</span>:Object</code> &mdash; The relevantContext parameter that was given when the callback was added.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">callback</span>:Function</code> &mdash; The function to remove from the list of callbacks.
		 </td></tr></table></p></div><a name="resumeCallbacks()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">resumeCallbacks</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function resumeCallbacks():void</code><p></p><p></p><p>
		 This should be called after delayCallbacks() to resume the callbacks.
		 If delayCallbacks() is called multiple times, resumeCallbacks() must be called the same number of times in order to resume the callbacks.
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="ICallbackCollection.html#delayCallbacks()" target="">delayCallbacks()</a><br/><a href="ICallbackCollection.html#callbacksAreDelayed" target="">callbacksAreDelayed</a></div></div><a name="triggerCallbacks()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">triggerCallbacks</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function triggerCallbacks():void</code><p></p><p></p><p>
		 This will increase the triggerCounter, run immediate callbacks, and trigger grouped callbacks to be called later.
		 If delayCallbacks() was called, the callbacks will not be called immediately.
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="ICallbackCollection.html#delayCallbacks()" target="">delayCallbacks()</a></div></div><br/><br/><hr><br/><p></p><center class="copyright"><footer></footer><br/>Wed Jun 28 2017, 02:22 PM -04:00  </center></div></body></html><!--<br/>Wed Jun 28 2017, 02:22 PM -04:00  -->